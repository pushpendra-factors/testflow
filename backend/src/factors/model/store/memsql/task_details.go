// Register Task
// Get Id, frequency By Name
// Get metadata, update metadata - later

package memsql

import (
	C "factors/config"
	"factors/model/model"
	U "factors/util"
	"net/http"

	"github.com/jinzhu/gorm"
	log "github.com/sirupsen/logrus"
)

func (store *MemSQL) RegisterTaskWithDefaultConfiguration(taskName string, source string, frequency int, isProjectEnabled bool) (uint64, int, string) {
	return store.RegisterTask(taskName, source, frequency, isProjectEnabled, 1, 0, -1, true, 0)
}

func (store *MemSQL) RegisterTask(taskName string, source string, frequency int, isProjectEnabled bool, frequencyInterval int, skipStartIndex int, skipEndIndex int, recurrence bool, offsetStartMinutes int) (uint64, int, string) {
	// check if its a duplicate named task
	// write a handler for this
	// source can be anything
	// frequency type validation
	// task_id is autogenerated
	logCtx := log.WithFields(log.Fields{"task_name": taskName, "frequency": frequency, "frequencyInterval": frequencyInterval, "skipStartIndex": skipStartIndex, "skipEndIndex": skipEndIndex})

	if taskName == "" || frequency == 0 {
		logCtx.Error("Missing required field.")
		return 0, http.StatusBadRequest, "Missing task_name/frequency"
	}

	if !(frequency == model.Hourly || frequency == model.Daily || frequency == model.Weekly || frequency == model.Stateless) {
		logCtx.Error("Incorrect frequency")
		return 0, http.StatusBadRequest, "incorrect frequency"
	}

	if frequency == model.Weekly {
		if skipStartIndex != 0 || skipEndIndex != -1 {
			logCtx.Error("Weekly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex")
			return 0, http.StatusBadRequest, "Weekly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex"
		}
	}

	if frequency == model.Stateless {
		if skipStartIndex != 0 || skipEndIndex != -1 || recurrence == false || offsetStartMinutes != 0 || frequency != 1 {
			logCtx.Error("stateless job doesnt allow these parameter - skipStartIndex/skipEndIndex/recurrence/offsetStartMinutes/frequency")
			return 0, http.StatusBadRequest, "stateless job doesnt allow these parameter - skipStartIndex/skipEndIndex/recurrence/offsetStartMinutes/frequency"
		}
	}

	if !isValidFrequency(frequency, frequencyInterval, skipStartIndex, skipEndIndex, offsetStartMinutes) {
		logCtx.Error("Incorrect frequency parameters")
		return 0, http.StatusBadRequest, "incorrect frequency parameters"
	}
	db := C.GetServices().Db

	taskDetails := model.TaskDetails{
		ID:                 U.GetUUID(),
		TaskName:           taskName,
		Source:             source,
		Frequency:          frequency,
		FrequencyInterval:  frequencyInterval,
		SkipStartIndex:     skipStartIndex,
		SkipEndIndex:       skipEndIndex,
		Recurrence:         recurrence,
		OffsetStartMinutes: offsetStartMinutes,
		IsProjectEnabled:   isProjectEnabled,
		CreatedAt:          U.TimeNow(),
		UpdatedAt:          U.TimeNow(),
	}

	taskNameFilter := &model.TaskDetails{
		TaskName: taskName,
	}

	taskDetailsByName := make([]model.TaskDetails, 0)
	db.Where(taskNameFilter).Find(&taskDetailsByName)
	if len(taskDetailsByName) > 0 {
		logCtx.Error("TaskName already exist")
		return 0, http.StatusConflict, "TaskName already exist"
	}

	if err := db.Create(&taskDetails).Error; err != nil {
		logCtx.Error(err.Error())
		return 0, http.StatusConflict, err.Error()

	}
	return taskDetails.TaskID, http.StatusCreated, ""
}

func isValidFrequency(frequency, frequencyInterval, skipStartIndex int, skipEndIndex int, offsetStart int) bool {
	if frequency == model.Hourly {
		if skipEndIndex > 23 {
			return false
		}
		if offsetStart >= 60 {
			return false
		}
		if frequencyInterval+skipStartIndex <= 24 && (skipEndIndex-skipStartIndex >= frequencyInterval || skipEndIndex == -1) {
			return true
		}
	}
	if frequency == model.Daily {
		if skipEndIndex > 6 {
			return false
		}
		if offsetStart >= 24*60 {
			return false
		}
		if frequencyInterval+skipStartIndex <= 7 && (skipEndIndex-skipStartIndex >= frequencyInterval || skipEndIndex == -1) {
			return true
		}
	}
	if frequency == model.Weekly {
		if skipEndIndex > 3 {
			return false
		}
		if offsetStart >= 7*24*60 {
			return false
		}
		if frequencyInterval+skipStartIndex <= 4 && (skipEndIndex-skipStartIndex >= frequencyInterval || skipEndIndex == -1) {
			return true
		}
	}
	if frequency == model.Stateless {
		return true
	}
	return false
}

func (store *MemSQL) GetTaskDetailsByName(taskName string) (model.TaskDetails, int, string) {
	// no such taskname
	// proper details
	logCtx := log.WithFields(log.Fields{"task_name": taskName})
	taskDetails := model.TaskDetails{}
	if taskName == "" {
		logCtx.Error("missing taskName")
		return taskDetails, http.StatusBadRequest, "missing taskname"
	}

	taskNameFilter := &model.TaskDetails{
		TaskName: taskName,
	}

	db := C.GetServices().Db

	if err := db.Where(taskNameFilter).Find(&taskDetails).Error; err != nil {
		if gorm.IsRecordNotFoundError(err) {
			logCtx.Error("record with this task name is not found")
			return taskDetails, http.StatusNotFound, "record with this task name is not found"
		}
		logCtx.Error(err.Error())
		return taskDetails, http.StatusInternalServerError, err.Error()
	}
	return taskDetails, http.StatusOK, ""
}

func (store *MemSQL) GetTaskDetailsById(taskID uint64) (model.TaskDetails, int, string) {
	// no such taskname
	// proper details
	logCtx := log.WithFields(log.Fields{"taskID": taskID})
	taskDetails := model.TaskDetails{}
	if taskID == 0 {
		logCtx.Error("missing taskID")
		return taskDetails, http.StatusBadRequest, "missing taskID"
	}

	taskNameFilter := &model.TaskDetails{
		TaskID: taskID,
	}

	db := C.GetServices().Db

	if err := db.Where(taskNameFilter).Find(&taskDetails).Error; err != nil {
		if gorm.IsRecordNotFoundError(err) {
			logCtx.Error("record with this task id is not found")
			return taskDetails, http.StatusNotFound, "record with this taskID is not found"
		}
		logCtx.Error(err.Error())
		return taskDetails, http.StatusInternalServerError, err.Error()
	}
	return taskDetails, http.StatusOK, ""
}
