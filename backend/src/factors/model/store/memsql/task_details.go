// Register Task
// Get Id, frequency By Name
// Get metadata, update metadata - later

package memsql

import (
	C "factors/config"
	"factors/model/model"
	U "factors/util"
	"net/http"
	"time"

	"github.com/jinzhu/gorm"
	log "github.com/sirupsen/logrus"
)

func (store *MemSQL) RegisterTaskWithDefaultConfiguration(taskName string, source string, frequency int, isProjectEnabled bool) (uint64, int, string) {
	logFields := log.Fields{
		"task_name":          taskName,
		"source":             source,
		"frequency":          frequency,
		"is_project_enabled": isProjectEnabled,
	}
	defer model.LogOnSlowExecutionWithParams(time.Now(), &logFields)
	return store.RegisterTask(taskName, source, frequency, isProjectEnabled, 1, 0, -1, true, 0)
}

func (store *MemSQL) RegisterTask(taskName string, source string, frequency int, isProjectEnabled bool, frequencyInterval int, skipStartIndex int, skipEndIndex int, recurrence bool, offsetStartMinutes int) (uint64, int, string) {
	logFields := log.Fields{
		"task_name":            taskName,
		"source":               source,
		"frequency":            frequency,
		"is_project_enabled":   isProjectEnabled,
		"frequency_interval":   frequencyInterval,
		"skip_start_index":     skipStartIndex,
		"skip_end_index":       skipEndIndex,
		"recurrence":           recurrence,
		"offset_start_minutes": offsetStartMinutes,
	}
	defer model.LogOnSlowExecutionWithParams(time.Now(), &logFields)
	// check if its a duplicate named task
	// write a handler for this
	// source can be anything
	// frequency type validation
	// task_id is autogenerated
	logCtx := log.WithFields(logFields)
	if taskName == "" || frequency == 0 {
		logCtx.Error("Missing required field.")
		return 0, http.StatusBadRequest, "Missing task_name/frequency"
	}

	if !(frequency == model.Hourly || frequency == model.Daily || frequency == model.Weekly || frequency == model.Stateless || frequency == model.Monthly || frequency == model.Quarterly) {
		logCtx.Error("Incorrect frequency")
		return 0, http.StatusBadRequest, "incorrect frequency"
	}

	if frequency == model.Weekly {
		if skipStartIndex != 0 || skipEndIndex != -1 {
			logCtx.Error("Weekly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex")
			return 0, http.StatusBadRequest, "Weekly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex"
		}
	}
	if frequency == model.Monthly {
		if skipStartIndex != 0 || skipEndIndex != -1 {
			logCtx.Error("monthly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex")
			return 0, http.StatusBadRequest, "monthly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex"
		}
	}
	if frequency == model.Quarterly {
		if skipStartIndex != 0 || skipEndIndex != -1 {
			logCtx.Error("quarterly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex")
			return 0, http.StatusBadRequest, "quarterly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex"
		}
	}
	if frequency == model.Stateless {
		if skipStartIndex != 0 || skipEndIndex != -1 || recurrence == false || offsetStartMinutes != 0 || frequency != 1 {
			logCtx.Error("stateless job doesnt allow these parameter - skipStartIndex/skipEndIndex/recurrence/offsetStartMinutes/frequency")
			return 0, http.StatusBadRequest, "stateless job doesnt allow these parameter - skipStartIndex/skipEndIndex/recurrence/offsetStartMinutes/frequency"
		}
	}

	if !isValidFrequency(frequency, frequencyInterval, skipStartIndex, skipEndIndex, offsetStartMinutes) {
		logCtx.Error("Incorrect frequency parameters")
		return 0, http.StatusBadRequest, "incorrect frequency parameters"
	}
	db := C.GetServices().Db

	taskDetails := model.TaskDetails{
		ID:                 U.GetUUID(),
		TaskName:           taskName,
		Source:             source,
		Frequency:          frequency,
		FrequencyInterval:  frequencyInterval,
		SkipStartIndex:     skipStartIndex,
		SkipEndIndex:       skipEndIndex,
		Recurrence:         recurrence,
		OffsetStartMinutes: offsetStartMinutes,
		IsProjectEnabled:   isProjectEnabled,
		CreatedAt:          U.TimeNowZ(),
		UpdatedAt:          U.TimeNowZ(),
	}

	taskNameFilter := &model.TaskDetails{
		TaskName: taskName,
	}

	taskDetailsByName := make([]model.TaskDetails, 0)
	db.Where(taskNameFilter).Find(&taskDetailsByName)
	if len(taskDetailsByName) > 0 {
		logCtx.Error("TaskName already exist")
		return 0, http.StatusConflict, "TaskName already exist"
	}

	if err := db.Create(&taskDetails).Error; err != nil {
		logCtx.WithError(err).Error("Failure in RegisterTask")
		return 0, http.StatusConflict, err.Error()

	}
	return taskDetails.TaskID, http.StatusCreated, ""
}

func isValidFrequency(frequency, frequencyInterval, skipStartIndex int, skipEndIndex int, offsetStart int) bool {
	logFields := log.Fields{
		"frequency":          frequency,
		"frequency_interval": frequencyInterval,
		"skip_start_index":   skipStartIndex,
		"skip_end_index":     skipEndIndex,
		"offset_start":       offsetStart,
	}
	defer model.LogOnSlowExecutionWithParams(time.Now(), &logFields)
	if frequency == model.Hourly {
		if skipEndIndex > 23 {
			return false
		}
		if offsetStart >= 60 {
			return false
		}
		if frequencyInterval+skipStartIndex <= 24 && (skipEndIndex-skipStartIndex >= frequencyInterval || skipEndIndex == -1) {
			return true
		}
	}
	if frequency == model.Daily {
		if skipEndIndex > 6 {
			return false
		}
		if offsetStart >= 24*60 {
			return false
		}
		if frequencyInterval+skipStartIndex <= 7 && (skipEndIndex-skipStartIndex >= frequencyInterval || skipEndIndex == -1) {
			return true
		}
	}
	if frequency == model.Weekly {
		if offsetStart >= 7*24*60 {
			return false
		}
		return true
	}
	if frequency == model.Monthly {
		if offsetStart >= 7*24*60 {
			return false
		}
		return true
	}
	if frequency == model.Quarterly {
		if offsetStart >= 7*24*60 {
			return false
		}
		return true
	}
	if frequency == model.Stateless {
		return true
	}
	return false
}

func (store *MemSQL) GetTaskDetailsByName(taskName string) (model.TaskDetails, int, string) {
	logFields := log.Fields{
		"task_name": taskName,
	}
	defer model.LogOnSlowExecutionWithParams(time.Now(), &logFields)
	// no such taskname
	// proper details
	logCtx := log.WithFields(logFields)
	taskDetails := model.TaskDetails{}
	if taskName == "" {
		logCtx.Error("missing taskName")
		return taskDetails, http.StatusBadRequest, "missing taskname"
	}

	taskNameFilter := &model.TaskDetails{
		TaskName: taskName,
	}

	db := C.GetServices().Db

	if err := db.Where(taskNameFilter).Find(&taskDetails).Error; err != nil {
		if gorm.IsRecordNotFoundError(err) {
			logCtx.Error("record with this task name is not found")
			return taskDetails, http.StatusNotFound, "record with this task name is not found"
		}
		logCtx.WithError(err).Error("Failure in GetTaskDetailsByName")
		return taskDetails, http.StatusInternalServerError, err.Error()
	}
	return taskDetails, http.StatusOK, ""
}

func (store *MemSQL) GetTaskDetailsById(taskID uint64) (model.TaskDetails, int, string) {
	logFields := log.Fields{
		"task_id": taskID,
	}
	defer model.LogOnSlowExecutionWithParams(time.Now(), &logFields)
	// no such taskname
	// proper details
	logCtx := log.WithFields(logFields)
	taskDetails := model.TaskDetails{}
	if taskID == 0 {
		logCtx.Error("missing taskID")
		return taskDetails, http.StatusBadRequest, "missing taskID"
	}

	taskNameFilter := &model.TaskDetails{
		TaskID: taskID,
	}

	db := C.GetServices().Db

	if err := db.Where(taskNameFilter).Find(&taskDetails).Error; err != nil {
		if gorm.IsRecordNotFoundError(err) {
			logCtx.Error("record with this task id is not found")
			return taskDetails, http.StatusNotFound, "record with this taskID is not found"
		}
		logCtx.WithError(err).Error("Failure in GetTaskDetailsById")
		return taskDetails, http.StatusInternalServerError, err.Error()
	}
	return taskDetails, http.StatusOK, ""
}
