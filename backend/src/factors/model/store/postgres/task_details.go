// Register Task
// Get Id, frequency By Name
// Get metadata, update metadata - later

/* Description of all the methods and the corresponding params
GetTaskDetailsByName:
Each task(cron job) registered with the task table has a unique name.
This method takes input of the name and returns all the details about the task

GetTaskDetailsById:
Each task(cron job) registered with the task table has a unique id.
This method takes input of the name and returns all the details about the task

RegisterTask
TaskName: Name of the cron job. Going forward this will be reference for any further operations and dependency configurations
Source: Some description - optional
Frequency: if its Hourly/Monthly/Daily/Stateless(runs whenever configured)
IsProjectEnabled: If the task is run per project or if the task is run for all projects
FrequencyInterval: if value = 2 and frequency = Hourly, then it runs every 2 hours. Default = 1
SkipStartIndex: If the job needs to start from 2nd hour and not run for 0 and 1 then specify this as 2. Default = 0
SkipEndIndex: if the job needs to be run only till 2PM and not run further for any hours in the day then specify this value as 14. Default = -1
Recurrence: if this is set to false, then it runs only for the first value of the interval. Default: true
OffsetStartMinutes: Delay in minutes after which the job is to be started. Eg: if the job is to be run at 1:15, 2:15, then mention as 15
DelayAlertThresholdHours: This is to configure Alerting. if the job didnt run successfully for more than 4hrs then alert.
*/
package postgres

import (
	C "factors/config"
	"factors/model/model"
	U "factors/util"
	"net/http"

	"github.com/jinzhu/gorm"
	log "github.com/sirupsen/logrus"
)

func (pg *Postgres) RegisterTaskWithDefaultConfiguration(taskName string, source string, frequency int, isProjectEnabled bool) (uint64, int, string) {
	return pg.RegisterTask(taskName, source, frequency, isProjectEnabled, 1, 0, -1, true, 0)
}

func (pg *Postgres) RegisterTask(taskName string, source string, frequency int, isProjectEnabled bool, frequencyInterval int, skipStartIndex int, skipEndIndex int, recurrence bool, offsetStartMinutes int) (uint64, int, string) {
	// check if its a duplicate named task
	// write a handler for this
	// source can be anything
	// frequency type validation
	// task_id is autogenerated
	logCtx := log.WithFields(log.Fields{"task_name": taskName, "frequency": frequency, "frequencyInterval": frequencyInterval, "skipStartIndex": skipStartIndex, "skipEndIndex": skipEndIndex})

	if taskName == "" || frequency == 0 {
		logCtx.Error("Missing required field.")
		return 0, http.StatusBadRequest, "Missing task_name/frequency"
	}

	if !(frequency == model.Hourly || frequency == model.Daily || frequency == model.Weekly || frequency == model.Stateless || frequency == model.Monthly || frequency == model.Quarterly) {
		logCtx.Error("Incorrect frequency")
		return 0, http.StatusBadRequest, "incorrect frequency"
	}

	if frequency == model.Weekly {
		if skipStartIndex != 0 || skipEndIndex != -1 {
			logCtx.Error("Weekly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex")
			return 0, http.StatusBadRequest, "Weekly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex"
		}
	}

	if frequency == model.Monthly {
		if skipStartIndex != 0 || skipEndIndex != -1 {
			logCtx.Error("monthly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex")
			return 0, http.StatusBadRequest, "monthly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex"
		}
	}
	if frequency == model.Quarterly {
		if skipStartIndex != 0 || skipEndIndex != -1 {
			logCtx.Error("quarterly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex")
			return 0, http.StatusBadRequest, "quarterly job doesnt allow these parameter overrides - skipStartIndex/skipEndIndex"
		}
	}

	if frequency == model.Stateless {
		if skipStartIndex != 0 || skipEndIndex != -1 || recurrence == false || offsetStartMinutes != 0 || frequency != 1 {
			logCtx.Error("stateless job doesnt allow these parameter - skipStartIndex/skipEndIndex/recurrence/offsetStartMinutes/frequency")
			return 0, http.StatusBadRequest, "stateless job doesnt allow these parameter - skipStartIndex/skipEndIndex/recurrence/offsetStartMinutes/frequency"
		}
	}

	if !isValidFrequency(frequency, frequencyInterval, skipStartIndex, skipEndIndex, offsetStartMinutes) {
		logCtx.Error("Incorrect frequency parameters")
		return 0, http.StatusBadRequest, "incorrect frequency parameters"
	}
	db := C.GetServices().Db

	taskDetails := model.TaskDetails{
		TaskName:                 taskName,
		Source:                   source,
		Frequency:                frequency,
		FrequencyInterval:        frequencyInterval,
		SkipStartIndex:           skipStartIndex,
		SkipEndIndex:             skipEndIndex,
		Recurrence:               recurrence,
		OffsetStartMinutes:       offsetStartMinutes,
		IsProjectEnabled:         isProjectEnabled,
		DelayAlertThresholdHours: 0,
		CreatedAt:                U.TimeNowZ(),
		UpdatedAt:                U.TimeNowZ(),
	}

	if err := db.Create(&taskDetails).Error; err != nil {
		if U.IsPostgresUniqueIndexViolationError("task_name_unique_idx", err) {
			logCtx.Error("TaskName already exist")
			return 0, http.StatusConflict, "TaskName already exist"
		} else {
			logCtx.Error(err.Error())
			return 0, http.StatusConflict, err.Error()
		}
	}
	return taskDetails.TaskID, http.StatusCreated, ""
}

func isValidFrequency(frequency, frequencyInterval, skipStartIndex int, skipEndIndex int, offsetStart int) bool {
	if frequency == model.Hourly {
		if skipEndIndex > 23 {
			return false
		}
		if offsetStart >= 60 {
			return false
		}
		if frequencyInterval+skipStartIndex <= 24 && (skipEndIndex-skipStartIndex >= frequencyInterval || skipEndIndex == -1) {
			return true
		}
	}
	if frequency == model.Daily {
		if skipEndIndex > 6 {
			return false
		}
		if offsetStart >= 24*60 {
			return false
		}
		if frequencyInterval+skipStartIndex <= 7 && (skipEndIndex-skipStartIndex >= frequencyInterval || skipEndIndex == -1) {
			return true
		}
	}
	if frequency == model.Weekly {
		if offsetStart >= 7*24*60 {
			return false
		}
		return true
	}
	if frequency == model.Monthly {
		if offsetStart >= 7*24*60 {
			return false
		}
		return true
	}
	if frequency == model.Quarterly {
		if offsetStart >= 7*24*60 {
			return false
		}
		return true
	}
	if frequency == model.Stateless {
		return true
	}
	return false
}

func (pg *Postgres) GetTaskDetailsByName(taskName string) (model.TaskDetails, int, string) {
	// no such taskname
	// proper details
	logCtx := log.WithFields(log.Fields{"task_name": taskName})
	taskDetails := model.TaskDetails{}
	if taskName == "" {
		logCtx.Error("missing taskName")
		return taskDetails, http.StatusBadRequest, "missing taskname"
	}

	taskNameFilter := &model.TaskDetails{
		TaskName: taskName,
	}

	db := C.GetServices().Db

	if err := db.Where(taskNameFilter).Find(&taskDetails).Error; err != nil {
		if gorm.IsRecordNotFoundError(err) {
			logCtx.Error("record with this task name is not found")
			return taskDetails, http.StatusNotFound, "record with this task name is not found"
		}
		logCtx.Error(err.Error())
		return taskDetails, http.StatusInternalServerError, err.Error()
	}
	return taskDetails, http.StatusOK, ""
}

func (pg *Postgres) GetTaskDetailsById(taskID uint64) (model.TaskDetails, int, string) {
	// no such taskname
	// proper details
	logCtx := log.WithFields(log.Fields{"taskID": taskID})
	taskDetails := model.TaskDetails{}
	if taskID == 0 {
		logCtx.Error("missing taskID")
		return taskDetails, http.StatusBadRequest, "missing taskID"
	}

	taskNameFilter := &model.TaskDetails{
		TaskID: taskID,
	}

	db := C.GetServices().Db

	if err := db.Where(taskNameFilter).Find(&taskDetails).Error; err != nil {
		if gorm.IsRecordNotFoundError(err) {
			logCtx.Error("record with this task id is not found")
			return taskDetails, http.StatusNotFound, "record with this taskID is not found"
		}
		logCtx.Error(err.Error())
		return taskDetails, http.StatusInternalServerError, err.Error()
	}
	return taskDetails, http.StatusOK, ""
}
